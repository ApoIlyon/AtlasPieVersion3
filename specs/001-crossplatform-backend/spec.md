# Feature Specification: Cross-Platform Backend Architecture

**Feature Branch**: `001-crossplatform-backend`  
**Created**: 2025-11-13  
**Status**: Draft  
**Input**: User description: "Сделать Tauri-приложение кроссплатформенным на базе архитектуры бэкендов, повторяющей подход Kando, с рабочим MVP для Wayland/X11."

## User Scenarios & Testing *(mandatory)*

<!--
  IMPORTANT: User stories should be PRIORITIZED as user journeys ordered by importance.
  Each user story/journey must be INDEPENDENTLY TESTABLE - meaning if you implement just ONE of them,
  you should still have a viable MVP (Minimum Viable Product) that delivers value.
  
  Assign priorities (P1, P2, P3, etc.) to each story, where P1 is the most critical.
  Think of each story as a standalone slice of functionality that can be:
  - Developed independently
  - Tested independently
  - Deployed independently
  - Demonstrated to users independently
-->

### User Story 1 - Wayland пользователь переключает меню (Priority: P1)

Настольный пользователь на Wayland (GNOME/KDE) запускает автозапускаемый демон приложения и привязывает системный хоткей к вызову `autohotpie-tauri --toggle`, чтобы мгновенно показывать или скрывать радиальное меню поверх активного экрана.

**Why this priority**: Без этого сценария MVP на Wayland не приносит ценности, так как меню не может быть показано пользователем.

**Independent Test**: Запустить приложение, вызвать CLI `--toggle` и убедиться, что оверлей появляется и исчезает без ошибок, не влияя на другие сценарии.

**Acceptance Scenarios**:

1. **Given** демон запущен и окно оверлея скрыто, **When** пользователь вызывает `autohotpie-tauri --toggle`, **Then** оверлей появляется в позиции курсора или в центре экрана, если позиция недоступна.
2. **Given** оверлей отображается, **When** пользователь повторно вызывает `autohotpie-tauri --toggle`, **Then** окно скрывается и приложение возвращается в состояние ожидания.

---

### User Story 2 - Windows пользователь сохраняет текущий опыт (Priority: P2)

Пользователь Windows продолжает использовать привычный глобальный хоткей, регистрируемый приложением, и не сталкивается с регрессиями после внедрения архитектуры бэкендов.

**Why this priority**: Поддержка основной пользовательской базы без ухудшений критична для выпуска новой версии.

**Independent Test**: Включить Windows-бэкенд, зарегистрировать глобальный хоткей и убедиться, что переключение оверлея и обработка событий работают как в текущей версии.

**Acceptance Scenarios**:

1. **Given** WindowsBackend активен и хоткей зарегистрирован, **When** пользователь нажимает заданную комбинацию, **Then** окно оверлея появляется/исчезает без ошибок.
2. **Given** пользователь отвязывает хоткей, **When** комбинация нажимается, **Then** приложение не реагирует и логирует отсутствие привязки.

---

### User Story 3 - Настройка хоткея в альтернативных DE (Priority: P3)

Пользователь Hyprland/Niri или другого DE настраивает глобальный хоткей в конфиге окружения, вызывающий `autohotpie-tauri --toggle`, и получает доступ к меню без встроенной поддержки хоткеев в приложении.

**Why this priority**: Поддержка кастомных оконных менеджеров расширяет аудиторию Wayland без ожидания полноценных бэкендов.

**Independent Test**: Сценарий воспроизводится через скрипт/конфиг DE, который вызывает CLI; проверяется, что единственный вызов переключает состояние оверлея без зависаний.

**Acceptance Scenarios**:

1. **Given** приложение работает в режиме демона, **When** внешний менеджер вызывает `--toggle`, **Then** оверлей отображается поверх активного рабочего стола.
2. **Given** оверлей активен, **When** вызов повторяется, **Then** оверлей скрывается, а фокус возвращается на ранее активное окно.

---

### Edge Cases

- Что происходит, если активен Wayland-бэкенд, но получение позиции курсора не поддерживается — оверлей должен открываться в центре активного монитора.
- Как система реагирует, если пользователь запускает `--toggle`, когда основной экземпляр приложения не работает — CLI возвращает понятную ошибку и предлагает запустить демон.
- Как приложение ведёт себя, если одновременно приходят несколько событий хоткея (DE и встроенный бэкенд) — должны использоваться id привязок для предотвращения гонок и двойных показов.
- Что происходит при падении одного из бэкендов при инициализации — должен использоваться fallback на заглушку с журналированием и уведомлением пользователя о недоступности функции.

## Requirements *(mandatory)*

<!--
  ACTION REQUIRED: The content in this section represents placeholders.
  Fill them out with the right functional requirements.
-->

### Functional Requirements

- **FR-001**: Приложение ДОЛЖНО предоставлять трейт Backend с методами для управления глобальными хоткеями, позицией курсора и показом оверлея, доступный из основного модуля Tauri.
- **FR-002**: Система ДОЛЖНА содержать диспетчер, автоматически выбирающий реализацию Backend в зависимости от ОС и окружения (Windows, X11, GNOME Wayland, KDE Wayland, прочие).
- **FR-003**: WindowsBackend ДОЛЖЕН обеспечивать регистрацию/снятие глобальных хоткеев и обработку событий через текущий плагин таури без изменения пользовательского поведения.
- **FR-004**: Для X11 и Wayland-бэкендов Система ДОЛЖНА предоставлять заглушки с чётко документированными ограничениями и логированием, чтобы фронтенд понимал недоступность функций.
- **FR-005**: Команда `toggle_pie_menu` в backend ДОЛЖНА получать позицию указателя (или центр экрана при отсутствии поддержки) и переключать состояние окна pie-overlay.
- **FR-006**: CLI-режим `autohotpie-tauri --toggle` ДОЛЖЕН обращаться к уже работающему экземпляру приложения и инициировать IPC-вызов `toggle_pie_menu`.
- **FR-007**: Фронтенд ДОЛЖЕН заменить локальную обработку глобальных хоткеев на IPC-вызов backend-команды, сохранив текущую UX-модель отображения меню.
- **FR-008**: Документация ДОЛЖНА описывать способы настройки хоткеев в популярных Wayland окружениях, а также дорожную карту развития бэкендов.

### Key Entities

- **Backend**: Абстракция, инкапсулирующая операции с глобальными хоткеями, позицией курсора и управлением pie-overlay; включает идентификатор платформы и методы жизненного цикла.
- **BackendDispatcher**: Компонент, выбирающий и инициализирующий подходящую реализацию Backend на основании платформы и параметров запуска.
- **PieOverlayWindow**: Прозрачное окно Tauri, отображающее меню; хранит состояние видимости и координаты последнего показа.
- **ToggleInvocation**: Представление вызова `toggle_pie_menu` (через IPC или CLI), содержащее источник вызова, timestamp и ожидаемый результат.

## Success Criteria *(mandatory)*

<!--
  ACTION REQUIRED: Define measurable success criteria.
  These must be technology-agnostic and measurable.
-->

### Measurable Outcomes

- **SC-001**: Показ/скрытие pie-overlay через `--toggle` завершается менее чем за 200 мс на поддерживаемых платформах.
- **SC-002**: Windows пользователи выполняют привычное переключение меню с долей успешных попыток ≥ 99% в течение недели после обновления.
- **SC-003**: Не менее 80% тестируемых Wayland окружений из документации демонстрируют успешный сценарий `--toggle` без ручных исправлений конфигурации.
- **SC-004**: Документация Wayland setup получает не менее 90% положительных отзывов (по внутреннему опросу/ревью) относительно понятности шагов настройки.

### Assumptions & Dependencies

- Пользовательская система уже предоставляет механизм глобальных хоткеев (через DE или менеджер окон), который можно направить на CLI вызов.
- На ранних этапах Wayland окружения не предоставляют API для регистрации глобальных хоткеев внутри приложения, поэтому полагаемся на конфигурацию DE.
- Дополнения (GNOME extension, KDE портал и др.) будут планироваться отдельно и не входят в MVP.
